\subsection{Návrh implementácie pre LDGM}
	\noindent
		V tejto èasti navrhneme implementáciu LDGM podpisovej schémy a predstavíme konkrétne algoritmy
		na generovanie k¾úèov, podpisov a overovacie funkcie. 
	
	\subsubsection{Funkcia $\phi$}
		\noindent
			Dôleitou súèasou pre celú implementáciu, je zvoli funkciu $\phi$, ktorá jednoznaène mapuje vektor dåky $n$ 
			na vektor dåky $l$ s váhou $t$. Pre tento úèel zvolíme algoritmus, ktorı navrhol Sendrier v rámci CFS schémy v [xx]. Tento algoritmus má lineárnu zloitos a
			oproti algoritmu, ktorı pouili autori LDGM schémy ponúka vırazné zrıchlenie celého vıpoètu.
			
			Implementácia ako ju navrhol Sendrier je uvedená v algoritme XX.
			
			\begin{algorithm}[ht]
				\caption{Funkcia $\phi$}
				\label{phi-function}
				\begin{algorithmic}
					\INPUT Vektor dåky $n$, parameter $t$
					\OUTPUT Vektor dåky $l$ s váhou $t$

				\end{algorithmic}
			\end{algorithm}
			
	\subsubsection{Funkcia $\psi$}
	
	\subsubsection{Generovanie k¾úèov}
		\noindent
			Generovanie páru k¾úèov sa skladá z viacerıch krokov
			
			\begin{description}
				\item[$\bullet$] Vygenerova generujúcu maticu $G$
				\item[$\bullet$] Vygenerova maticu $Q$
				\item[$\bullet$] Vygenerova maticu $S$
				\item[$\bullet$] Vypoèíta maticu $H_{pub}$
			\end{description}
			
			Pseudokód generovania k¾úèov je zhrnutı v algoritme XX
			
			\begin{algorithm}[h]
				\caption{Generovanie k¾úèov}
				\label{key-gen}
				\begin{algorithmic}
					\INPUT Parametre kódu a schémy - $params$
					\OUTPUT Pár k¾úèov
			
			
					\State $G \gets generateGenMatrix(params)$
					
					\Repeat
						\State $Q \gets generateMatrixQ(params)$
						\State $Q_{inv} \gets tryToInvert(Q)$
					\Until{$exists(Q_{inv})$}
					
										
					\Repeat
						\State $S \gets generateMatrixS(params)$
						\State $S_{inv} \gets tryToInvert(S)$
					\Until{$exists(S_{inv})$}
					
					\State
					\State $H_{pub} \gets buildMatrixH(G, Q_{inv}, S_{inv})$	
					\State $PublicKey \gets H_{pub}$
					\State $PrivateKey \gets G, Q_{inv}, S_{inv}$
					
					\State \Return $PrivateKey$, $PublicKey$

					
				\end{algorithmic}
			\end{algorithm}
	
				
			Kadı krok generovania rozoberieme v osobitnej èasti. 
			Pod¾a návrhu schémy potrebujeme inverzné matice $Q^{-1}$ a $S^{-1}$, take matice $Q$ a $S$ musia by regulárne.
			Pseudokód v algoritme XX ukazuje, e sme na generovanie matíc $Q$ a $S$ zvolili stratégiu generuj a testuj a teda
			ak sa nám nepodarí vygenerovnú maticu invertova, generovanie opakujeme. 
			
			\noindent
			Invertovanie kvazicyklickıch matíc zohráva pri generovaní k¾úèov podstatnú úlohu. Preto predtım ako si priblíime 
			algoritmy na generovanie matíc $Q$ a $S$, sa budeme venova invertovaniu kvázicyklickıch matíc.
	
	\subsubsection{Invertovanie QC matice}
		\noindent
			Binárne cirkulantné matice ve¾kosti $n$ môu by reprezentované polynómom $P(x)$ z $GF(2)/x^n-1$. 
			$P(x)$ je stupòa maximálne $n-1$ a reprezentuje prvı riadok cirkulantnej matice, $i$-ty riadok matice je reprezentovanı
			polynómom $x^{i-1}P(x)$ pre $i \in {1, ..., n}$.
			
		\noindent 
			Kvázicyklická matica je matica, ktorej všetky prvky sú polynómy z $GF(2)/x^n-1$. Kadı polynóm predstavuje jeden cirkulantnı
			blok. Pre kvázicyklickú maticu môeme riadkovo ekvivalentné operácie rozšíri o operácie, ktoré pracujú nad blokmi. To znamená,
			e na poèítanie inverznej matice môeme poui Gaussovu eliminaènú metódu nad okruhom polynómov. Kvázicyklickú maticu $M$ ve¾kosti $n$ rozšírime
			zprava o jednotkovú maticu (tie v QC tvare). Rošírenú maticu upravíme do redukovaného stupòovitého tvaru. Maticu $M^{-1}$ potom tvoria
			ståpce $<n+1, 2n>$.
			
				\begin{algorithm}[h]
				\caption{Invertovanie QC matice}
				\label{inv-qc}
				\begin{algorithmic}
					\INPUT QC matica $M$
					\OUTPUT QC matica $M^{-1}$ ak existuje, inak 0
					
					\State $M_{eye} \gets [M | I]$
					
					\For{$i \gets 1$ \To $n$}
						\For{$j \gets i$ \To $n$}
							\If{$existsPolynomialInverse(M_{eye}[j][i])$}
								\State $inverse \gets polynomialInverse(M_{eye}[j][i])$
								\State $swap(M_{eye}[i], M_{eye}[j])$
								\State $M_{eye}[i] \gets M_{eye}[i] * inverse$
								\Break
							\EndIf
						\EndFor
				
						\If{$exists(inverse)$}
							\For{$j \gets 1$ \To $n$}
								\If{$j=i$}
									\Continue
								\EndIf
								\State $M_{eye}[j] \gets M_{eye}[j] + M_{eye}[i]*M_{eye}[j][i]$
							\EndFor
						\Else
							\State \Return 0
						\EndIf
					\EndFor
					
					\State \Return $M_{eye}[1:n][n+1:2n]$
					
				\end{algorithmic}
			\end{algorithm}

					
		\noindent
			Na to aby sme pomocou jedného riadku mohli eliminova ostatné, potrebujeme nájs vedúci prvok (pivot). V polynomickej reprezentácii to znamená nájs
			v ståpci prvok, ktorı sa dá invertova modulo $x^n-1$. Inverziu h¾adáme pomocou Euklidovho rozšíreného algoritmu. Ak nájdeme pivot, pripoèítame k ostatnım 
			riadkom takı násobok riadku, ktorı obsahuje pivot, aby sme v ståpci nad aj pod ním dostali nuly. Ak v ståpci pivot nenájdeme, buï matica nie je regulárna
			a teda inverzia neexistuje, alebo je štruktúra matice taká, e jednoduchou Gaussovou elimináciou nie sme schopní inverziu nájs. Je dôleité zdôrazni, e
			èi inverzia existuje alebo nie, nie sme schopní z vısledku algoritmu urèi. Ak inverzia neexistuje, algoritmus je neúspešnı, ale môe nasta prípad keï
			inverzia existuje ale napriek tomu algoritmus inverziu nevypoèíta.
			
		\noindent
			V tabu¾ke XX sú vısledky meraní èasovej zloitosti a úspešnosti invertovania pre rôzne ve¾kosti matíc

			
	\subsubsection{Generovanie matice G}
	
	\subsubsection{Generovanie matice Q}
		\noindent
			Ako bolo uvedené v predošlej èasti, matica $Q$ sa skladá z matíc $R$ a $T$, ktoré su blokovo cirkulantné. 
			Matica $R$ vznikne ako produkt $a^{T}b \otimes 1_{p,p}$, matice $a$, $b$ náhodne vygenerujeme v závislosti od parametra $z$.
			Matica $T$ sa skladá z cirkulantnıch matíc s rozmerom $p \times p$. A váha kadého riadku a ståpca je $w_t$, nepárne.
			Uvedieme si algoritmus na generovanie matice $T$.
			\begin{algorithm}[h]
				\caption{Generovanie regulárnej matice z cirkulantnıch blokov}
				\label{gen-mat-reg}
				\begin{algorithmic}
					\INPUT Poèet cirkulantnıch blokov - $r_0$, ve¾kos bloku - $p$, predpísaná váha $w_t$
					\OUTPUT Regulárna matica z cirkulatnıch blokov s predpísanou váhou riadkov a ståpcov
					
					\State Vytvorime riadok z blokov tak, aby prvy blok bol jednotkova matica, zvysok su bloky
							s parnou vahou
					\State Ostatne riadky vytvorime posuvanim blokov z prveho "riadku" 
					\State Dostaneme na diagonale jednotkove matice, zvysok matice s parnym poctom jednotiek
					\State Premiesame blokovo riadky a stlpce
				\end{algorithmic}
			\end{algorithm}
			
			Ak súèet R+T nie je regulárna matica, skúsime vygenerova T znova.		

			
			
		